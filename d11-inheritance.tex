\section{Inheritance}
\label{sec:inheritance-1}

Repeating code is a bad thing. When the same code is used in more than
one place in a program, it is a disaster waiting to happen. Sooner or
later, one of the copies of the code will be changed (probably to fix
a bug), but not all copies will be changed\ldots and unpredictable things
will happen (never good). 

We already know how to use methods in a class to avoid repetition of
code inside the class. When the code is inside a method, the
programmer can just call the method from different areas of the code
and the same instructions will be always executed (probably with
different values for the parameters). In this section, we will move
one step further to avoid code repetition by using \emph{inheritance} to
prevent code repetitions \emph{among} classes. 

\subsection{Extending already-existing classes}
\label{sec:extend-alre-exist}

From all the forms of inheritance, the easiest to understand is the
extension of already existing classes. This is done by means of the
keyword \verb+extends+. You can think of this keyword as stating a
``is a'' relationship. 

Let's assume that we had a class \verb+Ebook+,
part of a program to run an electronic book reader. The class would
several methods, including some like \verb+nextPage()+,
\verb+prevPage()+, and \verb+readAloud(int page)+. When the next
version of our electronic book reader comes out, it includes a new
feature to regulate the background light of the screen. At this point
we have two options. First, we can add a new method
\verb+setLight(int)+ to the \verb+Ebook+ class to regulate the
background light; however, this method would also be part of the
software running in all the non-regulable e-books that we sell from
then on. A second possibility, is to create two different classes,
\verb+Ebook+ and \verb+LightEbook+, each of them used for a different
hardware; but this leads to a lot of methods being repeated, which is
bad. 

There is a third, much better possibility. We can make
\verb+LightBook+ extend \verb+Ebook+ (comments ommited for the sake of
brevity): 

\begin{verbatim}
    public class LighEbook extends Ebook {
        private int lightLevel = 100;
        public void setLight(int newLevel) {
            this.lightLevel = newLevel;
        }
    }
\end{verbatim}

You can see that extending a class is very easy: just say that you are
extending it! Then you will be able to use all the public methods (and
some more, see below on Section~\ref{sec:protected-keyword}) from
the class that you are extending without the need to implement them
again. In other words, you can call \verb+nextPage()+ on a
\verb+LightEbook+ object exactly in the same way as you would do it
on a \verb+Ebook+ object. 

The base class that is extended is called the \emph{parent class} or
\emph{superclass}\footnote{In this context, ``super'' is as in Latin
  ``up'', without connotations of big, extra, or more
  powerful. Remember that the convention in computing is that general
  classes or interfaces are ``up'' and more specific or extended classes
  are ``down''.), 
while the extending class is called a \emph{subclass}. When there are
many levels of hierarchy (a class extends a class that extends another
class, etc), those classes up in the hierarchy are called
\emph{ancestor classes}, while those down in the hiearchy are called
\emph{descendant classes}. 

\paragraph{Everything is an object!}
\label{sec:everything-an-object}

In Java, every class extends class \verb+Object+ or descends from a
class that extends \verb+Object+. \verb+Object+ is a class from the
core Java library that provides a few methods that every other class
can use. The most commonly used is \verb+equals()+, which compares two
objects and returns \verb+true+ if they are the same (according to
some class-specific rules) and \verb+false+ otherwise. 

As everything is an \verb+Object+ by default, you do not need to write
explicitly (\verb+...extends Object {+). Java will do it for
you. Programmer must only explicitly say which class they are
extending when they are extending a class that is not \verb+Object+.

\paragraph{Final classes}
\label{sec:final-classes}

You remember that we could use the keyword \verb+final+ to indicate
that a variable hold a constant value, i.e.~that the variable could
not be changed. In a similar way, we can use it to tell the compiler
that a class cannot be changed either. A class defined as \verb+final+
cannot be extended; trying to do so will result in an error at compile
time. 


\subsection{Top-down inheritance}
\label{sec:top-down-inheritance}

We have already seen that we can use interfaces to specify what a
class is like or, in other words, what is its behaviour: the methods
that are public and can be used by other classes. For example, we may
have an interface \verb+Animal+ that was implemented by classes
\verb+Dog+, \verb+Human+, and \verb+Horse+. The interface may define
methods like \verb+move()+, \verb+makeSound()+, and
\verb+breath()+. The three classes would each implement each method. 

Now, it is quite possible that the implementations of movement and
sounds are quite different, but it is quite possible that methods like
\verb+breath()+ are very similar or the same between the three
classes. As we know, repetition of code is bad: if we have a bug
in the \verb+breath()+ method, we will be in trouble if we forget to
fix it in all classes. It would be much better if we could have the
same method in just one place so that each class could use it, in the
same way that the code in a method can be used from anywhere in the
class. 

It turns out it is quite possible to do this in Java: we can put the
code into the interface\ldots almost. Actually, what we need to do is
to transform the interface into an \emph{abstract class}, and then
make the other classes \emph{extend} it. Assuming
that the original interface looked like this (JavaDoc comments ommited
for the sake of space):

\begin{verbatim}
    public interface Animal {
         void move(int meters);
         String makeSound();
         void breath(int air);
    }
\end{verbatim}

\ldots if we implement the method \verb+breath()+, the resulting
abstract class could look like this: 

\begin{verbatim}
    public abstract class Animal {
         private int oxygen = 0;

         public abstract void move(int meters);
         public abstract String makeSound();
         public void breath(int air) {
             this.oxygen += air / 4;
         }
    }        
\end{verbatim}

As you can see, there are many differences between an interface and an
abstract class: 

\begin{itemize}
\item First and foremost, an interface never contains any actual code,
  while an abstract ---like any other class--- can contain statements
  that perform some action.
\item Interfaces are \emph{implemented}, while abstract classes are
  \emph{extended}.
\item All methods in an interface are by definition public and
  abstract (i.e.~without actual code), so there is no need to write it
  down (but it can be done). On the other hand, methods in an abstract
  class can be private or public, abstract or not, and it must be said
  explicitly for each of them.
\item Abstract classes can contain mutable fields. All fields on an
  interface are by definition static and final (i.e.~constant).
\end{itemize}

There are also some similarities: 

\begin{itemize}
\item Both abstract classes and interfaces can be used as data
  types to declare a variable of a complex type.
\item Neither can be used to instantiate an object using \verb+new+
  (because neither contains a full ``blueprint'' of what the new
  object would look like). 
\end{itemize}

\subsection{Bottom-up inheritance}
\label{sec:boot-up-inher}

Sometimes, inheritance is a consequence of the design of your
program: you have an interface that is implemented by several classes
and then decide to add a little code into it and convert it into an
abstract class. 

Sometimes it happens the other way around. Sometimes you have two or
more classes that are apparently unrelated, and then realise that they
have the same code. 

\begin{verbatim}
    public class ManorHouse {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
       // ...
    }
    (...)
    public class Castle {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
       // ...
    }       
\end{verbatim}

Code repetition is bad. The method should be put in a parent class: 

\begin{verbatim}
    public abstract class GateGuardedBuilding {
       private Gate gate;
       // ...
       public void closeForTheNight() {
           gate.moveInwards(90);
           gate.getLock().setLocked(true);
       }
    }
    (...)
    public class ManorHouse extends GateGuardedBuilding {
       // ...
    }
    (...)
    public class Castle extends GateGuardedBuilding {
       // ...
    }       
\end{verbatim}

The method \verb+closeForTheNight()+ is available to both
\verb+ManorHouse+ and \verb+Castle+ because they are extending
\verb+GateGuardedBilding+. 

There are situations, though, in which this ``repetition of code'' is not so clear-cut. Look at the
following simplified example:  

\begin{verbatim}
    public class DrinkRefrigerator {
        // ...
        public int buyCan(int money) {
           if (money < price) {
               return money;
           } 
           int change = money - price;
           releaseCan();
           return change;
        }
        // ...
    }
    (...)
    public class ChocBarVendingMachine {
        // ...
        public int getBar(int moneyGiven) {
           if (moneyGiven < price) {
               return moneyGiven;
           } 
           giveChocolateBar();
           int change = moneyGiven - price;
           return change;
        }
        // ...
    }
\end{verbatim}

Although it may not seem at first that a \verb+DrinkRefrigerator+ and
a \verb+ChocBarVendingMachine+ have much in common, an analysis of the
code of methods \verb+buyCan()+ and \verb+getBar()+ shows a strong
similarity, suggesting that the code should be abstracted away to a
parent class. How would it look like? Maybe something similar to this: 

\begin{verbatim}
    public Sale {
        public boolean sold; // public fields because it does not
        public int change;   //    have methods
    }
    (...)
    public abstract class VendingMachine {
        // ...
        public Sale buy(int money, int price) {
           Sale result = new Sale();
           if (money < price) {
               result.sold = false;
               result.change = money;
               return result;
           } else {
               result.sold = true;
               result.change = price - money;
               return result;
           }
        }
        // ...
    }
    (...)
    public class DrinkRefrigerator extends VendingMachine {
        // ...
        public int buyCan(int money) {
           Sale sale = buy(money, price);
           if (sale.sold) {
               releaseCan();
           } 
           return sale.change;
        }
        // ...
    }
    (...)
    public class ChocBarVendingMachine extends VendingMachine {
        // ...
        public int getBar(int money) {
           Sale sale = buy(money, price);
           if (sale.sold) {
               giveChocolateBar();
           }
           return sale.change;
        }
        // ...
    }
\end{verbatim}

The code in the subclasses is shorter and clearer because all the work
is done in the code that was abstracted and put in the parent
class. If this code was more complicated and involved several
comparisons or long intrincated calculations, the benefits would be
even greater. The ``repeated'' methods had two effects: a return value
(change) and a side effect (release can or chocolate bar). Because of
this, we needed to create a new class in order to be able to sort-of
returning two values from the new method. 

\subsection{Visibility revisited}
\label{sec:protected-keyword}

As it evolves and grows, a program can become really complex, usually
beyond of what its programmer(s) can cope with. We know that one of
the basic strategies to keep complexity under control is by hiding
information. 

Information is hidden by making it not-visible: visible fields can be
read and written, but non-visible fields cannot; visible methods can
be called, but non-visible fields cannot.  We have used two keywords
to control the visibility of our classes' fields and methods:
\verb+public+ and \verb+private+. Although these two keywords will
cover most of your needs as a programmer, it is good to know that
there are four levels of visibility in Java: public, protected,
default (package), and private.

\subsubsection*{Public}
\label{sec:public}

Public fields are visible to any other class, and can be read and
written accordingly. Letting other classes (even your classes) modify
the fields of your classes can have unpredictable effect in a
normal-size program, and that is why you should make all your fields
private as a rule of thumb. The only exception are the fields of
method-less just-used-as-intermediate-data classes. 

Public methods are visible to other classes and define the public
interface of your class. This is usually made explicit by implementing
one of more Java interfaces. Note that there is an ambiguity in
natural language here: the public methods of a class are its ``interface''
in the sense that they define how other classes can interact with it,
but that does not necessarily mean that the class \verb+implements+
(in the Java sense) a explicit Java \verb+interface+ defined in a
\verb+.java+ file. You should keep this distinction clear when you
read the documentation of software projects as both meanings of the
words are sometimes used without much care. 

\subsubsection{Protected}
\label{sec:protected}

Protected fields and methods are visible for classes in your package
(i.e.~the same folder/directory as the class) and for descendant
classes. There are a few cases in which the distinction
\verb+protected+ vs. \verb+public+ makes sense (i.e.~in event-oriented
architectures) but in most cases this nuance is not worth it, and that
is why many of the most recent programming languages do not include a
\verb+protected+ visibility and just use \verb+public+. 

As a rule of thumb, use always public if you want other classes to
call the methods in your class. However, it is important to understand
what \verb+protected+ means because you will find it often when you
read Java code, especially if it is old legacy code. 

\subsubsection{Default (i.e.~package)}
\label{sec:default-i.e.-package}

When the visibility of a field or method is not specified, its default
visibility is ``package-wide'', i.e.~it is visible to other classes in
the same package. There is not a keyword for declaring ``package''
visibility: fields and methods of unspecified visibility become
visible for other classes in the same package. 

Up to now, you have not noticed any difference
between \verb+public+ visibility and default visibility because all
your interacting classes have been part of the same package or were
part of the standard Java library (e.g.~String) and you used only
their public methods. 

When Java was originally created, making things visible to the same
package seemed like a good idea for several reasons. However, things
have changed over the years and it is very rare today to find a
situation where ``package'' visibility makes sense but \verb+public+
visibility does not, with the additional complexity of keeping track
and what is visible at which level. Therefore, you will very rarely
find default visibility in Java code for a good reason; it is almost
always a symptom of sloppy programming, a sign of a programming not
thinking properly about the design of their program or --even worse---
not understanding the difference between \verb+private+ and default
visibility.   

\subsubsection{Private}
\label{sec:private}

Private fields and methods are only seen inside their own class. This
is the most complete form of ``hiding'', and should be the default
option for all the fields and most of the methods (unless they are
defined in an interface, i.e.~they are useful for other classes). 

Note that \verb+private+ only determines visibility between classes,
not between objects. Objects of the same class are able to see each
other fields and methods. This is very evident in most implementations
of the \verb+.equals()+ method. 

\begin{verbatim}
    public class Integer {
        private int value;
        // ...
        public boolean equals(Integer other) {
            if (this.value == other.value) {
                return true;
            } else {
                return false;
            }
        }
    }
\end{verbatim}

Although the field \verb+value+ is private and cannot be seen from any
other class, any object of class \verb+Integer+ can see the
\verb+value+ method of other objects of the same class. 

\subsection{Changing (overriding) behaviour}
\label{sec:chang-overr-behav}

%    - overriding / overwriting
%      - annotation @Override
%      - equals(), hashcode()

\subsection{The keyword super}
\label{sec:keyword-super}

There are few keywords in Java that we have not seen yet, but one that
is extremely relevant when we talk about inheritance is
\verb+super+. This keyword designates the \emph{superclass} or
\emph{parent class}, and can be used to use methods defined in it, as
in this trivial example: 

\begin{verbatim}
    /**
     * This method does exactly the same as the method of the same
     * name of the parent class, plus printing a message on screen. 
     * /
    @Override
    public void someMethod() {
        super.someMethod();
        System.out.println("Calling someMethod() at subclass.");
    }
\end{verbatim}

Calling methods from the superclass is not very useful in practical
terms, there are few situations in which this is needed or
adequate. There is another use of super that is extremely important to
understand, and that is calling the constructor of the parent class
at the constructor of the subclass. This is so important it must be
done at the first line of the constructor: 

\begin{verbatim}
    public MyClass() {     public MyClass(arguments) {
        super();               super(arguments);
        // rest here...        // rest here...    
    }                      }
\end{verbatim}

If you try to do anything ---like initialising your fields--- before
the \verb+super(...)+ constructor is called, you will get an error
from the Java compiler. 

\paragraph{Hidden super()}
\label{sec:hidden-super}

You may be wondering how was it possible to create classes that did
not call the constructor lll

%    - super
%      - "hidden" super()

\subsection{The limits of inheritance}
\label{sec:limits-inheritance}

% diamond problems and all

\section{Final note: composition vs. inheritance}
\label{sec:final-note:-comp}

%    \item composition better than extension


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
