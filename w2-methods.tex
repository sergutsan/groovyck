
\section{Methods}
\label{sec:methods}

We have briefly introduced the concept of
\emph{methods}. In the last section we have seen that they have an
\emph{identifier}, like variables, and that they have (round)
brackets. Sometimes we can put variables or values inside the brackets
like with methods \verb+charAt()+ or \verb+substring()+ of class
String. 

Let's look at methods in a bit more detail now, because they are very
important. 

\subsection{Why are methods important?}

Imagine that you are writing a program in which you need to make some
checks on user input. For example, your program needs the user to
introduce several logins/usernames and the program must make sure that
they do not contain spaces and they are all lower case letters. You
could have some code like:

\begin{verbatim}
    String login = System.console().readLine();
    boolean loginIsValid = true;
    for (int i = 0; i < login.length(); i++) {
        char c = login.charAt(i);
        if (!Character.isLetter(c) || !Character.isLowerCase(c)) {
            loginIsValid = false;
        }
    }
\end{verbatim}

As you can see, the loop goes through the whole length of the string
\emph{login} checking that each and every character is a letter in
lower case. If that is not the case, the boolean flag
\emph{loginIsValid} is set to \verb+false+ so the program knows that a
new login must be asked from the user.

Now you can think of this code being necessary at different parts of
your program. This can be useful (1) when you are adding new users to the
program, (2) when you are changing the username of a user, and (3) when
you want to remove a user from the system, to name but a few. If you
have to write the same code for every single place that you need it,
you have too problems.

First of all, it is \textbf{boring}. You have to type it several
times. Even if you copy--and--paste, you have to find the file where
it is (normal programming projects have tens of hundreds of source
code files, and sometimes they are quite long). Programmers like to
make computers work for them and not the other way around.

Second, but most important, if you find an error (a so-called
\emph{bug}) in those lines of code, you only need to fix in one
place. If you have to fix it in several places, sooner or later you
will forget to do it because you are human. That means that your
program will still be \emph{buggy} even if you are sure you have fixed
it, which is the worse thing than can happen to you. There is a very
important rule in programming that is usually referred to as the DIE
principle: 

\begin{center}
\vspace{1cm}
\textbf{\large DIE: Duplication Is Evil}
\vspace{1cm}
\end{center}

Duplication of information will result in problems sooner or later, so
we must avoid it. This is what methods are for. They allow the
programmer to put code in just one place that can be used from
anywhere else in the program. This means that, for example, if you
need to fix a bug, you fix it in only one place; and if you need to
improve the code to add a new feature, or to make it faster, or for
any other reason, you only need to change it in one place. That way
you are sure that you fix things once and forever. 

Besides, separating code in methods also makes your code
clearer. Compare the easiness of reading the code above with the
following statement: 

\begin{verbatim}
    String login = System.console().readLine();
    boolean loginIsValid = containsOnlyLowerCaseLetters(login)
\end{verbatim}

What is under the hood of that \verb+containsOnlyLowerCaseLetters()+
method? Let's see it. 

\subsection{Defining a method}

A method is defined by its name, its return type, and the parameters
inside the brackets. We will look at parameters in the next section.

A method's name must be an identifier
like those used for variables: starting with a letter and consisting
of letters, digits, and underscores (``\_''). Actually, underscores
are rarely used when you are programming in Java. Methods
usually have names consisting of a single word
(e.g.~\verb+length()+) or several words in so-called \emph{camel case}
starting with a verb (e.g.~\verb+isLetter()+
or~\verb+containsOnlyLowerCaseLetters()+). Note that variables usually
have identifiers that are a noun or an adjective, not a verb.

The return type of a method is a data type, simple or complex, that is
returned by the method when it finishes. When a method finishes, it
must return a value of the appropriate data type by using the keyword
\verb+return+. For example, the method we defined above could look
like the following code:

\begin{verbatim}
    boolean containsOnlyLowerCaseLetters(String login) {
        boolean result = true;
        for (int i = 0; i < login.length(); i++) {
            char c = login.charAt(i);
            if (!Character.isLetter(c) || !Character.isLowerCase(c)) {
                loginIsValid = false;
            }
        }
        return result;
    }
\end{verbatim}

Note that the code is the same that we wrote before. The difference is
we only need to write it once and can use it from anywhere else in the
program just by using its name. We are avoiding duplication of
code. That is good. 

You will notice that this method has a return type ``boolean'', so we
must create a boolean variable and return it at the end. The return
statement is the last statement that is executed inside any method:
once you return the value, there is nothing else to do. This means
that we can make our method a bit more efficient by returning early: 

\begin{verbatim}
    boolean containsOnlyLowerCaseLetters(String login) {
        for (int i = 0; i < login.length(); i++) {
            char c = login.charAt(i);
            if (!Character.isLetter(c) || !Character.isLowerCase(c)) {
                return false;
            }
        }
        return true;
    }
\end{verbatim}

Instead of traversing the whole string, we return \verb+false+ as soon
as we find a character in the login that is not a letter or is not
in lower case. If we arrive at the end of the login, that means that
all characters are fine and we can return \verb+true+. Note that the
loop is automatically terminated when the method is finished,
i.e.~when the return value is given back. It does not matter if the
loop has run to the end or not, or whether there is more code after
the \verb+return+ statement. 

This is important.
It means that you can only return from a method once. Even if you have
several \verb+return+ statements, your program will only execute the
first one it encounters. This does not mean that you can only return
one piece of data from any method; remember that the return value can
be any simple or complex data (like String or Person). By returning a
complex type, you can return as much information as you want. 

You have noticed that there is something inside the round brackets, a
String called \emph{login}, that is used inside the method. The
variables inside the round brackets are called the \emph{parameters} of the
method. 

\subsection{Positional parameters}
\label{sec:pospar}

You can think of methods as small mini-programs: they get some input,
they produce some output. The output is the return value, the input
are the so-called \emph{positional parameters}. 

Positional parameters are declared in the same way as any other
variable. The programmer must specify the type and give it a name, an
identifier. Parameters can have any type, simple or complex, and
separated by commas. If a method does not return any value, the
keyword \verb+void+ is used as return data type. 

In the body of the method (what comes inside the curly
brackets) parameters are used the same as variables declared and
initialised inside the method. Parameters are initialised when the
method is called (see below). 

Some methods do not have any parameters. If that is the case, the
method is defined and called with an empty list of parameters,
i.e.~empty brackets. The method \verb+length()+ is an example of a
method without parameters. 

\emph{Positional} parameters get their name because they come in some
order and they must be called \emph{in the same order}. Let's see how
this is done. 

\subsection{Calling (i.e.~using) methods}
\label{sec:using}

You have already seen how to use some methods, like methods
\verb+length()+ or \verb+substring(int,int)+ of strings\footnote{As
  you can see, now that you know that methods have parameters I will
  start referring to them in a proper way, specifying the type of
  their parameters.}. They are methods of a
class, so you access them with the name of the variable and a dot: 

\begin{verbatim}
    int familyName = fullName.substring(6,12);
\end{verbatim}

This is called \emph{calling}, \emph{executing}, or \emph{running} the
method (the first term is more common). 
You call a method by using its name and specifying the value of its
parameters. 
It is important to call a
method with the right parameters in the right order. For example, if
you have a method like \verb+repeat(String s, int times)+ you 
cannot call it like \verb+repeat(3, "Some text")+ because you will get
an error. Note are well that you do not need to say the type of the
parameters: the computer already know because they are specified in
the method's definition. 

\subsection{Scope}

In a way, you can see the execution of a method as the execution of a
small program in which some of the variables (the parameters) are
initialised in advance (with the values given by the caller). 

A method has access to variables outside of it, but its own variables
are hidden from the rest of the world. They cannot be read or modified
from outside the method. In technical terms, the \emph{scope} of
variables inside the method is the method itself. 

Actually, scope is not just a property of methods. In Java, scope is
roughly defined by any pair of curly brackets, so loops and classes
have scope too. That is why you must use the name of a class to access
variables inside the class, because otherwise they are restricted to
be used \emph{in their scope}. 

But what happens with the method's parameters? They are like variables
for the method but they also come from outside the method, don't they?
Good question. 

When you call a method, the variables used to initialise the
parameters are \emph{copied}, and the copies are used instead of the
original variables. This means that any change to the method's
parameters is forgotten as soon as the method returns. You can check
for yourself by running the following code: 

\begin{verbatim}
    void add1000(int number) {
        println "Starting method, parameter is " + number;
        number = number + 500;
        println "In the middle of method, parameter is " + number;
        number = number + 500;
        println "Ending method, parameter is " + number;
    }
    int myNumber = 0;
    println "Starting program, my number is " + myNumber;
    add1000(myNumber);
    println "After the method is used, my number is " + myNumber;
\end{verbatim}

The output is: 

\begin{verbatim}
    Starting program, my number is 0
    Starting method, parameter is 0
    In the middle of method, parameter is 500
    Ending method, parameter is 1000
    After the method is used, my number is 0
\end{verbatim}

You can see that the value of \emph{myNumber} never changes. The
method made a copy of \emph{myNumber}, used it (under the name
\emph{number}) inside the method, and then forgot it as soon as the
\verb+return+ statement was reached. 

\subsubsection*{Void methods}
\label{void}

Note also that the method does not return anything (i.e.~return type
is \verb+void+). When this is the case, there is no need to have a
return statement because there is nothing to return, and the method
ends after the final statement is reached or when the first \verb+return+
statement is found (with no value). 


\subsubsection{Beware of parameters of complex types!}
\label{beware}



% scope and duplication of variables
  % beware of complex types!

% methods in classes

% side effects

% Flow of execution

% access levels


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
